#!/usr/bin/env python3
#
# COPYRIGHT: Yaroslav Halchenko 2018
#
# LICENSE: MIT
#
#  Permission is hereby granted, free of charge, to any person obtaining a copy
#  of this software and associated documentation files (the "Software"), to deal
#  in the Software without restriction, including without limitation the rights
#  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#  copies of the Software, and to permit persons to whom the Software is
#  furnished to do so, subject to the following conditions:
#
#  The above copyright notice and this permission notice shall be included in
#  all copies or substantial portions of the Software.
#
#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
#  THE SOFTWARE.
#

# Description for invocation
#  - you can specify a list of images, as their original docker/github ids
#    which should be considered. E.g.
#
#    scripts/create_singularities poldracklab/ds003-example bids/validator
#
#    will consider only two images - one for poldracklab and another one
#    bids/validator, the other ones will be reported skipped

from __future__ import annotations
from dataclasses import dataclass
import logging
import os
from pathlib import Path
import re
import subprocess
import sys
from typing import Any, Optional
import requests

log = logging.getLogger(__name__)


@dataclass
class Builder:
    images_dir: Path
    tmp_dir: Path
    githubids: set[str]

    def runcmd(self, *args: str, **kwargs: Any) -> subprocess.CompletedProcess:
        kwargs.setdefault("check", True)
        kwargs["cwd"] = str(self.images_dir)
        kwargs["env"] = {
            **os.environ,
            "TMPDIR": str(self.tmp_dir),
            "SINGULARITY_TMPDIR": str(self.tmp_dir),
        }
        return subprocess.run(args, **kwargs)

    @staticmethod
    def get_last_docker_version_tag(dh: str) -> Optional[str]:
        r = requests.get(f"https://registry.hub.docker.com/v2/repositories/{dh}/tags")
        r.raise_for_status()
        versions = [res["name"] for res in r.json()["results"]]
        if len(versions) > 1:
            # select only the ones which seems to be semantic and/or
            # master/latest.  Some release alpha releases, so probably would
            # skip those for now
            good_versions = [
                re.sub(r"^(([Vv]|version-|)([0-9]{1,10}\..*))", r"\3@\1", v)
                for v in versions
                if not (
                    re.search(r"[ab][0-9]+$", v)
                    or re.search(r"rc[0-9]*$", v)
                    or "master" in v
                )
            ]
            return max(good_versions, key=version_key, default=None)
        elif not versions:
            log.info(" %s no version. Tags: %s", dh, " ".join(versions))
            return None
        else:
            return versions[0]

    def create_singularity_file(
        self, dh: str, version_tag: str, version_pure: str, family: str
    ) -> SingularityFile:
        imagename = get_imagename(dh, family, version_pure)
        outdir = self.images_dir / family
        outdir.mkdir(parents=True, exist_ok=True)
        singfile = outdir / f"Singularity.{imagename}"
        # log.info("%s \t from \t %s:%s", singfile, dh, version_tag)
        # Do not recreate the file ATM. Since we changed the env vars we
        # define, we don't want to recreate it if already present
        if not singfile.exists():
            singfile.write_text(
                "#\n"
                "# Automagically prepared for ReproNim/containers distribution.\n"
                "# See http://github.com/ReproNim/containers for more info\n"
                "#\n"
                "Bootstrap: docker\n"
                f"From: {dh}:{version_tag}\n"
                "\n"
                "%post\n"
                "\n"
                "# Create commonly present root directories to avoid need in overlays not supported\n"
                "# on older systems\n"
                "mkdir -p /ihome /data /data2 /zfs /isi /dartfs /dartfs-hpc\n"
                "\n"
                "%environment\n"
                'export LANG="C.UTF-8"\n'
                'export LC_ALL="C.UTF-8"\n'
                "\n"
                "# TODO: Take advantage of the fact that it is a bids-app somehow?\n"
            )
            # Save it immediately and push for build process to start
            # Git branch should be configured properly to push
            self.runcmd(
                "datalad",
                "save",
                "-m",
                f"Adding singularity recipe for {dh}:{version_tag}",
                str(singfile),
            )
            self.runcmd("datalad", "push", "--data", "auto")
        return SingularityFile(sourcefile=singfile, imagename=imagename)

    def add_singularity_versioned_image(
        self,
        singfile: SingularityFile,
        repoid: str,
        family: str,
        origrepoid: Optional[str] = None,
    ) -> None:
        # If image repo id is different (e.g. ReproNim/containers) from
        # original repoid where we are getting image for (e.g. generating
        # Singularity containers from Docker images) -- specify it as 4th arg
        if origrepoid is None:
            origrepoid = repoid
        familyname = get_familyname(origrepoid, family)
        imagefile = singfile.build(self)
        if imagefile is not None:
            self.runcmd(
                "datalad",
                "save",
                "-m",
                f"Adding built image for {singfile.imagename}",
                str(imagefile),
            )
            self.runcmd(
                "datalad",
                "containers-add",
                familyname,
                "-i",
                str(imagefile),
                "--update",
                "--call-fmt",
                "{img_dspath}/scripts/singularity_cmd run {img} {cmd}",
            )
            self.runcmd("datalad", "push", "--data=auto")  # so we share with the world
            # TODO: later make it work with updating existing one. We will not
            # be able to use containers-add --update since original URL is
            # version specific. That is why it also does not make much sense to
            # create a image file without version. We better collect all
            # versions available, so in case an execution of previous version
            # is needed it could still be done "semi-manually".  May be just
            # via adding -c datalad.containers.NAME.image variable pointing to
            # the previous version of the container

    def generate_singularity_for_docker_image(self, githubid: str, family: str) -> None:
        dockerhubid = githubid.lower()
        if self.githubids and githubid not in self.githubids:
            log.info("skip %s", githubid)
            return
        log.info("%s <- docker %s", family, dockerhubid)
        last_version = self.get_last_docker_version_tag(dockerhubid)
        if last_version is not None:
            last_version_pure = re.sub(r"@.*\Z", "", last_version)
            last_version_tag = re.sub(r"^[^@]*@", "", last_version)
            # print(dockerhubid, last_version)
            singfile = self.create_singularity_file(
                dockerhubid, last_version_tag, last_version_pure, family
            )
            self.add_singularity_versioned_image(
                singfile, "ReproNim/containers", family, dockerhubid
            )


@dataclass
class SingularityFile:
    sourcefile: Path
    imagename: str

    def build(self, builder: Builder) -> Optional[Path]:
        # Returns the path to the new imagefile, or None if it already exists
        imagefilename = f"{self.imagename}.sing"
        imagefile = self.sourcefile.with_name(imagefilename)
        if not imagefile.exists() and not imagefile.is_symlink():
            # eventually can use docker builds, e.g.
            # docker run -it -v $PWD:$PWD -w $PWD --privileged quay.io/singularity/singularity:v3.5.1 build ./busybox.sing-3.5.1 ./Singularity.busybox
            # docker run -it -v $PWD:$PWD -w $PWD --entrypoint chown quay.io/singularity/singularity:v2.6 -- $UID.$GID ./busybox.sing
            # unfortunately 2.6 version tries to connect to docker service and
            # fails, thus can't fetch anything
            tmpfile = self.sourcefile.with_name(f"{imagefilename}.tmp")
            builder.runcmd(
                "sudo",
                "--preserve-env=TMPDIR,SINGULARITY_TMPDIR",
                "singularity",
                "build",
                str(tmpfile),
                str(self.sourcefile),
            )
            # abuse BTRFS CoW to avoid sudo/docker to chown
            builder.runcmd("cp", "--reflink=auto", str(tmpfile), str(imagefile))
            tmpfile.unlink()
            return imagefile
        else:
            return None


def version_key(vstr: str) -> tuple[tuple[int, ...], str]:
    m = re.match(r"[0-9]+(?:\.[0-9]+)*", vstr)
    assert m is not None
    return (tuple(int(c) for c in m[0].split(".")), vstr[m.end() :])


def get_familyname(repoid: str, family: str) -> str:
    name = re.sub(r"^[^/]*/", "", repoid)
    # sanitize for datalad not allowing _ in the container names
    name = name.replace("_", "-")
    return f"{family}-{name}"


def get_imagename(repoid: str, family: str, versiontag: str) -> str:
    familyname = get_familyname(repoid, family)
    return f"{familyname}--{versiontag}"


def main() -> None:
    logging.basicConfig(format="[%(levelname)-8s] %(message)s", level=logging.INFO)

    # Use local dedicated "tmp/" directory since any other might be too small
    topdir = Path(__file__).parent.parent
    topdir.mkdir(parents=True, exist_ok=True)
    builder = Builder(
        image_dir=topdir / "images",
        tmp_dir=topdir / "tmp",
        githubids=set(sys.argv[1:]),
    )

    # We are still using elderly singularity 2.6.1 to build images, so elderly
    # singularity could run images we generate, since images produced by 3
    # seems to not be usable with 2.
    r = subprocess.run(
        ["singularity", "--version"],
        check=True,
        stdout=subprocess.PIPE,
        universal_newlines=True,
    )
    if "2.6.1" not in r.stdout:
        log.error("singularity is 'too new'")
        sys.exit(1)

    r = requests.get(
        "https://raw.githubusercontent.com/BIDS-Apps/bids-apps.github.io/master/_config.yml"
    )
    r.raise_for_status()
    for line in r.text.splitlines():
        m = re.match(r" *dh:\s+(\S+)", line.rstrip("\n\r"))
        if m:
            dockerhubid = re.sub(r"[\"']", "", m[1])
            if "micalab/micapipe" not in dockerhubid:
                builder.generate_singularity_for_docker_image(dockerhubid, "bids")

    # validator is not bids-app but we will stick it along with bids
    builder.generate_singularity_for_docker_image("bids/validator", "bids")

    # Additional ones from Poldrack
    builder.generate_singularity_for_docker_image(
        "poldracklab/ds003-example", "poldracklab"
    )

    #
    # ReproNim
    #

    # "Native" Singularity image for ReproIn
    # TODO: figure out who would build those now that shub is gone?!
    # ATM: built locally and pushed to docker hub... so let's build from those
    builder.generate_singularity_for_docker_image("repronim/reproin", "repronim")

    # nipy/heudiconv
    builder.generate_singularity_for_docker_image("nipy/heudiconv", "nipy")

    # Docker image for simple_workflow
    builder.generate_singularity_for_docker_image(
        "ReproNim/simple_workflow", "repronim"
    )

    # neuronets
    builder.generate_singularity_for_docker_image("neuronets/kwyk", "neuronets")


if __name__ == "__main__":
    main()
