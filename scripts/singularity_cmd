#!/bin/bash
#emacs: -*- mode: shell-script; c-basic-offset: 4; tab-width: 4; indent-tabs-mode: t -*- 
#ex: set sts=4 ts=4 sw=4 noet:
#
# A helper to run/exec singularity images with sanitization:
#  - fake HOME with minimalistic .bashrc and .gitconfig
#  - dedicated /tmp /var/tmp
#  - cleansed environment variables
# while bind mounting (and starting from) current directory.
#
# COPYRIGHT: Yaroslav Halchenko 2019
#
# LICENSE: MIT
#
#  Permission is hereby granted, free of charge, to any person obtaining a copy
#  of this software and associated documentation files (the "Software"), to deal
#  in the Software without restriction, including without limitation the rights
#  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#  copies of the Software, and to permit persons to whom the Software is
#  furnished to do so, subject to the following conditions:
#
#  The above copyright notice and this permission notice shall be included in
#  all copies or substantial portions of the Software.
#
#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
#  THE SOFTWARE.
#

set -eu

# ANSI colors
black='\e[0;30m'
Black='\e[1;30m'
red='\e[0;31m'
Red='\e[1;31m'
green='\e[0;32m'
Green='\e[1;32m'
yellow='\e[0;33m'
Yellow='\e[1;33m'
blue='\e[0;34m'
Blue='\e[1;34m'
cyan='\e[0;36m'
Cyan='\e[1;36m'
white='\e[0;37m'
White='\e[1;37m'
NC='\e[0m' #no color

function msg() {
	color="$1"; shift;
	pref="$1: "; shift;

	for l in "$@"; do
		printf "${color}${pref}${l}$NC\n" >&2
		pref="   "
	done
}

function info() {
	msg "$green" "I" "$@"
}

function warning() {
	msg "$red" "W" "$@"
}

function error() {
	msg "$Red" "E" "$@"
	exit 1
}

#info "I am here" "and there"
#warning "one"
#error "one"
#error "very" "long one"
#exit 0

function has_changes() {
	git status -s | grep -q .
}

function singularity_version() {
	singularity --version | sed -e 's,^[^0-9]*,,g'
}

# https://stackoverflow.com/a/24067243
function version_gt() {
	test "$(printf '%s\n' "$@" | sort -V | head -n 1)" != "$1";
}

thisdir=$(dirname $0| xargs readlink -f)
updir=$(dirname "$thisdir")

cmd="${SINGULARITY_CMD:-$1}"; shift

# We might need to expand list of arguments
args=("$@")

#
# Pass other useful variables inside the container
#
if [ ! -z "${DATALAD_CONTAINER_NAME:-}" ]; then
	export SINGULARITYENV_DATALAD_CONTAINER_NAME="$DATALAD_CONTAINER_NAME"
fi

#
# Prepare bind mounts
#

# singularity bind mounts system /tmp, which might result in side-effects
# Create a dedicated temporary directory to be removed upon completion
tmpdir=$(mktemp -d --suffix=singtmp)
info "created temp dir $tmpdir"
trap "rm -fr '$tmpdir' && info 'removed temp dir $tmpdir'" exit

#
# Prepare for storing bash history in cmd='shell' mode
#
# Will be non-empty if some post-run handling is needed
FINAL_BASH_HISTORY=
TEMP_BASH_HISTORY_LOCAL=
if [ "$cmd" = "shell" ]; then
	# should be outside of $tmpdir so we could copy it there before
	# trap cleans things up
	histstamp=$(git describe --always)-$(date -Iseconds)
	TEMP_BASH_HISTORY_LOCAL=$(mktemp -t bash_history.$histstamp.XXXXXXXXX)
	TEMP_BASH_HISTORY_FILENAME=$(basename $TEMP_BASH_HISTORY_LOCAL)
	TEMP_BASH_HISTORY="$tmpdir/tmp/$TEMP_BASH_HISTORY_FILENAME"
	# singularity 2.x seems to mess with HISTFILE - cannot pass through!
	if version_gt 3 "$(singularity_version)"; then
		error "Can manipulate bash history only with singularity >= 3"
	fi
	# Expose it to singularity environment
	export SINGULARITYENV_HISTFILE="/tmp/$TEMP_BASH_HISTORY_FILENAME"
	# We will copy it only if it was clean and new changes emerged
	# Handle (save) protocol of interactive sessions
	if ! has_changes ; then
		# TODO: place at the top of the dataset!?
		FINAL_BASH_HISTORY=".repronim/bash_histories/$histstamp"
		# TODO: cleanup TEMP_BASH_HISTORY in case of crash?
	else
		warning "uncomitted changes present, 'shell' mode will NOT commit bash history." \
				"You will find stored history at $TEMP_BASH_HISTORY_LOCAL"
	fi
	if [ "$#" -gt 1 ]; then
		error "for 'shell' mode - do not provide any custom command. Got options: $@"
	fi
	cmd="exec"
	args+=(bash)
fi

#
# The actual invocation
#
singularity "$cmd" -e -c -W "$tmpdir" -H "$updir/binds/HOME" -B "$PWD" --pwd "$PWD" "${args[@]}"


#
# Handle possible digital objects to save/be added to be saved
#
if [ ! -z "$FINAL_BASH_HISTORY" ]; then
	if ! has_changes ; then
		# TODO: someone might want to just record his wonderings around, so
		#       might be worth an option to force saving history only
		info "no changes to the tree detected. Bash history will not be saved." \
			 "You will find stored history at $TEMP_BASH_HISTORY_LOCAL"
	else
		mkdir -p "$(dirname $FINAL_BASH_HISTORY)"
		mv "$TEMP_BASH_HISTORY" "$FINAL_BASH_HISTORY"
		# due to https://github.com/datalad/datalad/issues/3421 saving entire directory of histories
		datalad save \
				-m "[REPRONIM/CONTAINERS]: bash history for the interactive session

Actual changes might (or not, depending on the invocation) get committed in the next commit" \
				"$(dirname $FINAL_BASH_HISTORY)"
	fi
fi

if [ ! -z "$TEMP_BASH_HISTORY_LOCAL" ] && [ -e "$TEMP_BASH_HISTORY" ]; then
	# So we did create it but did not move to be saved, so let's expose locally before it is wiped out
	mv "$TEMP_BASH_HISTORY" "$TEMP_BASH_HISTORY_LOCAL"
fi
